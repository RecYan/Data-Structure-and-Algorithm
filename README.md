# Data Structure and Algorithm

---

1. 数组结构
+ 实现了数组的增删改查、实现了动态扩容和泛型
+ 分析了该类的相关算法复杂度

2. 栈结构
+ 基于上面的动态数组，实现了栈结构，模拟了push、pop、peek等相关方法
+ 使用该结构完成了leetcode第20题（括号匹配问题）

3. 队列结构
+ 基于原有的动态数组，实现了队列的基本操作
+ 使用循环队列改进了出栈时的复杂度  O(n)-->O(1)
+ 编写了测试用例进行了简单的运算测试，进行了10000次操作测试，耗时结果如下：
>ArrayQueue time: 4.317554243 s  
>loopQueue time: 0.012931983 s

4. 链表结构<真正的动态结构>
>动态数组、栈、队列 -->其底层依靠静态数组
>*动态*的特性主要由resize方法实现相应的扩容和缩容

+ 链表内部维护节点内部类，节点类中包含两个部分：存于节点的信息和执行下一个节点的next引用  
+ 实现了链表的添加、并使用虚拟头结点，对代码进行优化，重点关注add()，理解其中逻辑  
+ 实现了链表的删、改、查操作，需要注意cur节点和prev节点所规定的约束和size的取值范围【见代码注释】  
+ 使用上述实现的链表，模拟了栈数据结构  
+ 改进上述实现的链表，增加了tail尾节点，模拟了队数据结构，即head为队首、tail为队尾  
+ 在运算量超过百万次时，推荐使用基于数组的栈和链表结构，运算速度较快  
+ **理解递归思想、宏观表现和微观实现、注意画图理解<类似于程序栈操作>**  
+ **完成leetcode第205题，使用基本链表、带虚拟头结点链表、递归三种实现**  

5. 二分搜索树结构  
+ 二分搜索树中**元素需要具备可比性**  
+ 定义该二分搜索树中每个节点值都大于其左子树所有节点的值，小于其右子树所有节点的值，每颗子树都为二分搜索树  
>递归：**BST中递归思路**  
>1.递归终止条件  
>2.递归组成逻辑  
>3.对外暴露基本方法，屏蔽内部调用的递归方法  
+ 使用递归实现了基本的添加功能、查找功能*（注意理解递归写法、思路）*
+ **深度优先遍历**，递归实现了遍历的功能（前、中、后序），不同于上面两种操作，遍历需要顾及左右两个子树  
+ 使用非递归方式 利用*栈结构* 实现了前序遍历  
+ **广度优先遍历**，利用*队列结构* 实现了树的层序遍历  
+ 实现了删除最大、最小和指定值的操作【依据二分搜索树规律】  
+ Hibbard Deletion 删除BST中指定的元素  
> 三种情况：1.左子树为空、2.右子树为空、3.左右子树不为空：找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点，用这个节点顶替待删除节点的位置  


6.集合和映射
+ 基于BST实现了简易的Set集合

 
---

# 算法 #
1.基本排序算法  
>实现了 冒泡排序、选择排序、插入排序  
>递归实现了归并排序，体验了**分治**思想  
>使用该思想 解决了*小和问题*和*逆排序*问题  
![分治](https://github.com/RecYan/Data-Structure-and-Algorithm/blob/master/img/duipaixufenzhi.jpg) 








